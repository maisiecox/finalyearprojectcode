# See example 3.2.2.2. for an explanation of how it works and to see an image of the graph used
# Let the adjacency matrix here be B
B = [[ 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
     [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [ 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [ 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
     [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [ 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
     [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
     [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0],
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0],
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0],
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1],
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]]
print(B)
[[0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]]

# Initialize the vertices in the graph, as numbers through the range of the adjacency matrix B
vertex = "abcdefghijklmno"
b={}
for i in range(len(B)):
    b[vertex[i]] = i

    
# Add up the degrees of vertices, so they can eventually be organised from largest to smallest
d = []
for i in range(len(B)):
    d.append(sum(B[i]))

    
# Define the pobbible colour that can be given to vertices abcdefghijklmno
colour ={}
for i in range(len(B)):
    colour[vertex[i]]=["Yellow","Green","Blue","Red"]

    
# Select the colour candidate using the selection colour function such the degrees of vertices is from largest to smallest
sortedvertices=[]
selection=[]
for i in range(len(d)):
    max_=0
    j=0
    for j in range(len(d)):
        if j not in selection:
            if d[j]>max_:
                max_ = d[j]
...                 g = j
...     selection.append(g)
...     sortedvertices.append(vertex[g])
... 
...     
>>> # Look in the sortedvertices and set the colour with possible colours given in colour and then save the answer to solution. The colour used is then removed from colour as it has already been used
>>> solution={}
>>> for n in sortedvertices:
...     colourset = colour[n]
...     solution[n] = colourset[0]
...     adjacentvertex = B[b[n]]
...     for j in range(len(adjacentvertex)):
...         if adjacentvertex[j]==1 and (colourset[0] in colour[vertex[j]]):
...             colour[vertex[j]].remove(colourset[0])
... 
...             
>>> # Print the answer to the solution in the sorted order of the vertices "abcdefghijklmno"
>>> for a,b in sorted(solution.items()):
...     print("vertex",a,"=",b)
... 
...     
vertex a = Yellow
vertex b = Green
vertex c = Green
vertex d = Yellow
vertex e = Green
vertex f = Yellow
vertex g = Green
vertex h = Green
vertex i = Yellow
vertex j = Green
vertex k = Blue
vertex l = Yellow
vertex m = Blue
vertex n = Green
vertex o = Yellow
